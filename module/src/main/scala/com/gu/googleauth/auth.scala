package com.gu.googleauth

import java.math.BigInteger
import java.nio.charset.StandardCharsets.UTF_8
import java.security.SecureRandom
import java.time.Clock
import java.util.{Base64, Date}

import com.gu.googleauth.OAuthStateSecurityConfig._
import com.gu.googleauth.GoogleAuthFilters.LOGIN_ORIGIN_KEY
import io.jsonwebtoken.{Claims, Jws, Jwts, SignatureAlgorithm}
import org.joda.time.Duration
import play.api.http.HttpConfiguration
import play.api.libs.json.JsValue
import play.api.libs.ws.{WSClient, WSResponse}
import play.api.mvc.Results.Redirect
import play.api.mvc.{RequestHeader, Result}

import scala.concurrent.{ExecutionContext, Future}
import scala.language.postfixOps
import scala.util.{Failure, Success, Try}

/**
  * The configuration class for Google authentication
  * @param clientId The ClientID from the developer dashboard
  * @param clientSecret The client secret from the developer dashboard
  * @param redirectUrl The URL to return to after authentication has completed
  * @param domain An optional domain to restrict login to (e.g. guardian.co.uk)
  * @param maxAuthAge An optional duration after which you want a user to be prompted for their password again
  * @param enforceValidity A boolean indicating whether you want a user to be re-authenticated when their session expires
  * @param prompt An optional space delimited, case sensitive list of ASCII string values that specifies whether the
  *               Authorization Server prompts the End-User for reauthentication and consent
 * @param antiForgeryChecker configuration for the checks that ensure the OAuth callback can't be forged
  */
case class GoogleAuthConfig private(
  clientId: String,
  clientSecret: String,
  redirectUrl: String,
  domain: Option[String],
  maxAuthAge: Option[Duration],
  enforceValidity: Boolean,
  prompt: Option[String],
  antiForgeryChecker: OAuthStateSecurityConfig
)
object GoogleAuthConfig {
  private val defaultMaxAuthAge = None
  private val defaultEnforceValidity = true
  private val defaultPrompt = None

  def apply(
    clientId: String,
    clientSecret: String,
    redirectUrl: String,
    domain: String,
    maxAuthAge: Option[Duration] = defaultMaxAuthAge,
    enforceValidity: Boolean = defaultEnforceValidity,
    prompt: Option[String] = defaultPrompt,
    antiForgeryChecker: OAuthStateSecurityConfig

  ): GoogleAuthConfig = GoogleAuthConfig(clientId, clientSecret, redirectUrl, Some(domain), maxAuthAge, enforceValidity, prompt, antiForgeryChecker)

  /**
    * Creates a GoogleAuthConfig that does not restrict acceptable email domains.
    * This means any Google account can be used to gain access. If you mean to restrict
    * access to certain email domains use the `apply` method instead.
    */
  def withNoDomainRestriction(
    clientId: String,
    clientSecret: String,
    redirectUrl: String,
    maxAuthAge: Option[Duration] = defaultMaxAuthAge,
    enforceValidity: Boolean = defaultEnforceValidity,
    prompt: Option[String] = defaultPrompt,
    antiForgeryChecker: OAuthStateSecurityConfig
  ): GoogleAuthConfig =
    GoogleAuthConfig(clientId, clientSecret, redirectUrl, None, maxAuthAge, enforceValidity, prompt, antiForgeryChecker)
}

/**
  * When the OAuth callback returns to our app, we need to ensure that this is the end of a valid authentication
  * sequence that we initiated, and not a forged redirect. Rather than use a nonce, we use a signed session id
  * in a short-lifetime Json Web Token, allowing us to cope better with concurrent authentication requests from the
  * same browser session.
  *
  * "One good choice for a state token is a string of 30 or so characters constructed using a high-quality
  * random-number generator. Another is a hash generated by signing some of your session state variables with
  * a key that is kept secret on your back-end."
  * - https://developers.google.com/identity/protocols/OpenIDConnect#createxsrftoken
  *
  * The design here is partially based on a IETF draft for "Encoding claims in the OAuth 2 state parameter ...":
  * https://tools.ietf.org/html/draft-bradley-oauth-jwt-encoded-state-01
  */
case class OAuthStateSecurityConfig(
  secret: String,
  signatureAlgorithm: SignatureAlgorithm
) {


  def checkChoiceOfSigningAlgorithm(claims: Jws[Claims]): Try[Unit] =
    if (claims.getHeader.getAlgorithm == signatureAlgorithm.getValue) Success(()) else
      Failure(throw new IllegalArgumentException(s"the anti forgery token is not signed with $signatureAlgorithm"))


}

object OAuthStateSecurityConfig {

  val SessionIdJWTClaimPropertyName = "rfp" // see https://tools.ietf.org/html/draft-bradley-oauth-jwt-encoded-state-01#section-2

  def borrowSettingsFromPlay(httpConfiguration: HttpConfiguration): OAuthStateSecurityConfig = {
    OAuthStateSecurityConfig(httpConfiguration.secret.secret, SignatureAlgorithm.forName(httpConfiguration.session.jwt.signatureAlgorithm))
  }
}

class GoogleAuthException(val message: String, val throwable: Throwable = null) extends Exception(message, throwable)

object GoogleAuth {
  var discoveryDocumentHolder: Option[Future[DiscoveryDocument]] = None

  def discoveryDocument()(implicit context: ExecutionContext, ws: WSClient): Future[DiscoveryDocument] =
    if (discoveryDocumentHolder.isDefined) discoveryDocumentHolder.get
    else {
      val discoveryDocumentFuture = ws.url(DiscoveryDocument.url).get().map(r => DiscoveryDocument.fromJson(r.json))
      discoveryDocumentHolder = Some(discoveryDocumentFuture)
      discoveryDocumentFuture
    }


  def redirectToGoogle(config: GoogleAuthConfig, sessionId: String)
                      (implicit request: RequestHeader, context: ExecutionContext, ws: WSClient): Future[Result] = {
    val oAuthStateEncoding: OAuthState.Encoding = ???
    val oAuthState = OAuthState(sessionId, request.getQueryString(LOGIN_ORIGIN_KEY).get)
    val userIdentity = UserIdentity.fromRequest(request)
    val queryString: Map[String, Seq[String]] = Map(
      "client_id" -> Seq(config.clientId),
      "response_type" -> Seq("code"),
      "scope" -> Seq("openid email profile"),
      "redirect_uri" -> Seq(config.redirectUrl),
      "state" -> Seq(oAuthStateEncoding.stringify(oAuthState))) ++
      config.domain.map(domain => "hd" -> Seq(domain)) ++
      config.maxAuthAge.map(age => "max_auth_age" -> Seq(age.getStandardSeconds.toString)) ++
      config.prompt.map(prompt => "prompt" -> Seq(prompt)) ++
      userIdentity.map(_.email).map("login_hint" -> Seq(_))

    discoveryDocument().map(dd => Redirect(s"${dd.authorization_endpoint}", queryString))
  }

  def validatedUserIdentity(config: GoogleAuthConfig)
        (implicit request: RequestHeader, context: ExecutionContext, ws: WSClient): Future[UserIdentity] = {
    for {
      dd <- discoveryDocument()
      googleOAuthService = new GoogleOAuthService(???, dd)
      userIdentity <- googleOAuthService.fetchUserIdentityForCode(request.getQueryString("code").get)
    } yield userIdentity
  }
}
